---
title: 基础思维代码
date: 2025-12-18 23:00:00
tags: [算法, 死锁]
categories: [技术]
---

# 介绍

本文会持续介绍一些考察非算法的手撕代码，包括但不限于基础思维代码、数据结构代码、算法代码等。

# 死锁

死锁一直是常在学习计算机编程相关知识时需要特别注意的问题，下面是一个简单的死锁示例代码：

``` java
public class DeadLockDemo {
    // 定义两把锁对象
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) {
        // 线程1：先获取LOCK_A，再尝试获取LOCK_B
        new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println(Thread.currentThread().getName() + " 持有锁A，尝试获取锁B");
                try {
                    // 模拟业务耗时，放大死锁概率
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                synchronized (LOCK_B) {
                    System.out.println(Thread.currentThread().getName() + " 获取锁B，执行完成");
                }
            }
        }, "线程1").start();

        // 线程2：先获取LOCK_B，再尝试获取LOCK_A
        new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println(Thread.currentThread().getName() + " 持有锁B，尝试获取锁A");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                synchronized (LOCK_A) {
                    System.out.println(Thread.currentThread().getName() + " 获取锁A，执行完成");
                }
            }
        }, "线程2").start();
    }
}
```

上述代码最后会输出：
```
线程1 持有锁A，尝试获取锁B
线程2 持有锁B，尝试获取锁A
```
可以看到，线程1和线程2都在等待对方释放锁，从而导致死锁。