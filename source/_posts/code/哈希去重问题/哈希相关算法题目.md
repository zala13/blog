---
title: LeetCode 哈希系列
date: 2026-01-18 23:00:00
tags: [算法, 哈希]
categories: [编程]
toc: true  # 必须添加，强制当前文章启用TOC
---

242.有效的字母异位词	哈希	简单	通过	思路错误	https://leetcode.cn/problems/valid-anagram/	https://www.bilibili.com/video/BV1YG411p7BA	2026-01-10	
349. 两个数组的交集	哈希	简单	通过	需要Debug	https://leetcode.cn/problems/intersection-of-two-arrays/	https://www.bilibili.com/video/BV1ba411S7wu	2026-01-10	
两数之和	哈希	简单	通过	完全掌握	https://leetcode.cn/problems/two-sum/	https://www.bilibili.com/video/BV1aT41177mK	2026-01-15	
15. 三数之和	哈希	中等	通过	思路错误	https://leetcode.cn/problems/3sum/	https://www.bilibili.com/video/BV1GW4y127qo	2026-01-15	
18. 四数之和	哈希	中等	通过	思路错误	https://leetcode.cn/problems/4sum/	https://www.bilibili.com/video/BV1DS4y147US	2026-01-16	
第454题.四数相加II	哈希	中等	通过	思路错误	https://leetcode.cn/problems/4sum-ii/	https://www.bilibili.com/video/BV1Md4y1Q7Yh	2026-01-16	
383. 赎金信	哈希	简单	通过	完全掌握	https://leetcode.cn/problems/ransom-note/	https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF	2026-01-16	


454. 四数相加 II
已解答
中等
相关标签
premium lock icon
相关企业
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
 

示例 1：

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
示例 2：

输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
 

 解题思路
思路：

一采用分为两组，HashMap 存一组，另一组和 HashMap 进行比对。
这样的话情况就可以分为三种：
HashMap 存一个数组，如 A。然后计算三个数组之和，如 BCD。时间复杂度为：O(n)+O(n^3)，得到 O(n^3).
HashMap 存三个数组之和，如 ABC。然后计算一个数组，如 D。时间复杂度为：O(n^3)+O(n)，得到 O(n^3).
HashMap存两个数组之和，如AB。然后计算两个数组之和，如 CD。时间复杂度为：O(n^2)+O(n^2)，得到 O(n^2).
根据第二点我们可以得出要存两个数组算两个数组。
我们以存 AB 两数组之和为例。首先求出 A 和 B 任意两数之和 sumAB，以 sumAB 为 key，sumAB 出现的次数为 value，存入 hashmap 中。
然后计算 C 和 D 中任意两数之和的相反数 sumCD，在 hashmap 中查找是否存在 key 为 sumCD。
算法时间复杂度为 O(n2)。
代码
```
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        Map<Integer, Integer> map = new HashMap<>();
        //Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        for(int i = 0;i<A.length;i++){
            for(int j= 0;j<B.length;j++){
                int sumAB = A[i]+B[j];
                if(map.containsKey(sumAB)) map.put(sumAB,map.get(sumAB)+1);
                else map.put(sumAB,1);
            }
        }

        for(int i = 0;i<C.length;i++){
            for(int j = 0;j<D.length;j++){
                int sumCD = -(C[i]+D[j]);
                if(map.containsKey(sumCD)) res += map.get(sumCD);
            }
        }
        return res;
    }
}
```