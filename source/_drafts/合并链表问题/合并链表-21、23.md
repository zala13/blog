

# 21

合并两个有序链表
这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题，给你输入两个有序链表，请你把他俩合并成一个新的有序链表：

21. 合并两个有序链表 | 力扣 | LeetCode |  🟢
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]
提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列
题目来源：力扣 21. 合并两个有序链表。
javacpppythongojavascript

// 函数签名如下
ListNode mergeTwoLists(ListNode l1, ListNode l2);
这题比较简单，我们直接看解法：

javacpppythongojavascript

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null && p2 != null) {

            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p 指针不断前进
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
我们的 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，看如下 GIF：


形象地理解，这个算法的逻辑类似于拉拉链，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并。

下面是算法的可视化，你可以多次点击  这一行代码，即可看到  合并两个有序链表的过程：

 
算法可视化面板
代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂一些，需要额外处理指针 p 为空的情况。而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。


# 23

合并 k 个有序链表
看下力扣第 23 题「合并K个升序链表」：

23. 合并 K 个升序链表 | 力扣 | LeetCode |  🔴
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]
提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
题目来源：力扣 23. 合并 K 个升序链表。
javacpppythongojavascript

// 函数签名如下
ListNode mergeKLists(ListNode[] lists);
合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？

这里我们就要用到优先级队列这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点。关于优先级队列可以参考 优先级队列（二叉堆）原理及实现，本文不展开。

javacpppythongojavascript

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // 优先级队列，最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        // 将 k 个链表的头结点加入最小堆
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }

        while (!pq.isEmpty()) {
            // 获取最小节点，接到结果链表中
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p 指针不断前进
            p = p.next;
        }
        return dummy.next;
    }
}
你可以点开下面的可视化面板，点击  这一行代码，即可看到有序链表合并的过程：

 
算法可视化面板
这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 pq 中的元素个数最多是 
k
k，所以一次 poll 或者 add 方法的时间复杂度是 
O
(
l
o
g
k
)
O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 
O
(
N
l
o
g
k
)
O(Nlogk)，其中 
k
k 是链表的条数，
N
N 是这些链表的节点总数。

但在这里还可以用分治算法